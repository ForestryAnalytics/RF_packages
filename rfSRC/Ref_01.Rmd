Package ‘randomForestSRC’
August 18, 2018
Version 2.7.0
Date 2018-08-17
Title Random Forests for Survival, Regression, and Classification
(RF-SRC)
Author Hemant Ishwaran <hemant.ishwaran@gmail.com>, Udaya B. Kogalur <ubk@kogalur.com>
Maintainer Udaya B. Kogalur <ubk@kogalur.com>
BugReports https://github.com/kogalur/randomForestSRC/issues/new
Depends R (>= 3.1.0),
Imports parallel
Suggests glmnet, survival, pec, prodlim, mlbench, akima, caret
Description Fast OpenMP parallel processing for Breiman's random forests for survival, competing
risks, regression and classification based on Ishwaran and Kogalur's popular random survival
forests (RSF) package. Handles missing data and now includes multivariate, unsupervised
forests and quantile regression. New fast interface using subsampling.
License GPL (>= 3)
URL http://web.ccs.miami.edu/~hishwaran http://www.kogalur.com
https://github.com/kogalur/randomForestSRC
NeedsCompilation yes
Repository CRAN
Date/Publication 2018-08-17 22:10:03 UTC
R topics documented:
randomForestSRC-package . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2
breast . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5
find.interaction . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5
follic . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 8
hd . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 9
housing . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 10
impute . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 10
1
2 randomForestSRC-package
max.subtree . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 13
nutrigenomic . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 16
partial . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 17
pbc . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 20
plot.competing.risk . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 21
plot.rfsrc . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 22
plot.subsample . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 23
plot.survival . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 25
plot.variable . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 28
predict.rfsrc . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 31
print.rfsrc . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 39
quantileReg . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 40
rfsrc . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 43
rfsrc.news . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 60
rfsrcFast . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 61
rfsrcSyn . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 63
stat.split . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 66
subsample . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 68
tune . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 72
var.select . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 74
vdv . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 80
veteran . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 80
vimp . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 81
wihs . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 83
wine . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 84
Index 85
randomForestSRC-package
Random Forests for Survival, Regression, and Classification (RF-SRC)
Description
Fast OpenMP parallel processing unified treatment of Breiman’s random forests (Breiman 2001) for
a variety of data settings. Regression and classification forests are grown when the response is numeric
or categorical (factor), while survival and competing risk forests (Ishwaran et al. 2008, 2012)
are grown for right-censored survival data. Multivariate regression and classification responses as
well as mixed outcomes (regression/classification responses) are also handled. Also includes unsupervised
forests and quantile regression forests, quantileReg. Different splitting rules invoked
under deterministic or random splitting are available for all families. Variable predictiveness can
be assessed using variable importance (VIMP) measures for single, as well as grouped variables.
Missing data (for x-variables and y-outcomes) can be imputed on both training and test data. The
underlying code is based on Ishwaran and Kogalur’s now retired randomSurvivalForest package
(Ishwaran and Kogalur 2007), and has been significantly refactored for improved computational
speed.
randomForestSRC-package 3
Package Overview
This package contains many useful functions and users should read the help file in its entirety for
details. However, we briefly mention several key functions that may make it easier to navigate and
understand the layout of the package.
1. rfsrc
This is the main entry point to the package. It grows a random forest using user supplied
training data. We refer to the resulting object as a RF-SRC grow object. Formally, the resulting
object has class (rfsrc, grow).
2. rfsrcFast
A fast implementation of rfsrc using subsampling.
3. predict.rfsrc, predict
Used for prediction. Predicted values are obtained by dropping the user supplied test data
down the grow forest. The resulting object has class (rfsrc, predict).
4. max.subtree, var.select
Used for variable selection. The function max.subtree extracts maximal subtree information
from a RF-SRC object which is used for selecting variables by making use of minimal depth
variable selection. The function var.select provides an extensive set of variable selection
options and is a wrapper to max.subtree.
5. impute.rfsrc
Fast imputation mode for RF-SRC. Both rfsrc and predict.rfsrc are capable of imputing
missing data. However, for users whose only interest is imputing data, this function provides
an efficient and fast interface for doing so.
6. partial.rfsrc
Used to extract the partial effects of a variable or variables on the ensembles.
Source Code, Beta Builds and Bug Reporting
1. Regular stable releases of this package are available on CRAN at cran.r-project.org/
package=randomForestSRC
2. Interim unstable development builds with bug fixes and sometimes additional functionality are
available at github.com/kogalur/randomForestSRC
3. Bugs may be reported via github.com/kogalur/randomForestSRC/issues/new. Please
provide the accompanying information with any reports:
(a) sessionInfo()
(b) A minimal reproducible example consisting of the following items:
• a minimal dataset, necessary to reproduce the error
• the minimal runnable code necessary to reproduce the error, which can be run on the
given dataset
• the necessary information on the used packages, R version and system it is run on
• in the case of random processes, a seed (set by set.seed()) for reproducibility
4 randomForestSRC-package
OpenMP Parallel Processing – Installation
This package implements OpenMP shared-memory parallel programming if the target architecture
and operating system support it. This is the default mode of execution.
Additional instructions for configuring OpenMP parallel processing are available at kogalur.github.
io/randomForestSRC/building.html.
An understanding of resource utilization (CPU and RAM) is necessary when running the package
using OpenMP and Open MPI parallel execution. Memory usage is greater when running with
OpenMP enabled. Diligence should be used not to overtax the hardware available.
Author(s)
Hemant Ishwaran and Udaya B. Kogalur
References
Breiman L. (2001). Random forests, Machine Learning, 45:5-32.
Ishwaran H. and Kogalur U.B. (2007). Random survival forests for R, Rnews, 7(2):25-31.
Ishwaran H. (2007). Variable importance in binary regression trees and forests, Electronic J. Statist.,
1:519-537.
Ishwaran H., Kogalur U.B., Blackstone E.H. and Lauer M.S. (2008). Random survival forests, Ann.
App. Statist., 2:841-860.
Ishwaran H., Kogalur U.B., Gorodeski E.Z, Minn A.J. and Lauer M.S. (2010). High-dimensional
variable selection for survival data. J. Amer. Statist. Assoc., 105:205-217.
Ishwaran H., Kogalur U.B., Chen X. and Minn A.J. (2011). Random survival forests for highdimensional
data. Stat. Anal. Data Mining, 4:115-132
Ishwaran H., Gerds T.A., Kogalur U.B., Moore R.D., Gange S.J. and Lau B.M. (2014). Random
survival forests for competing risks. Biostatistics, 15(4):757-773.
Ishwaran H. and Malley J.D. (2014). Synthetic learning machines. BioData Mining, 7:28.
Ishwaran H. (2015). The effect of splitting on random forests. Machine Learning, 99:75-118.
Ishwaran H. and Lu M. (2018). Standard errors and confidence intervals for variable importance in
random forest regression, classification, and survival. Statistics in Medicine (in press).
Mantero A. and Ishwaran H. (2017). Unsupervised random forests.
O’Brien R. and Ishwaran H. (2017). A random forests quantile classifier for class imbalanced data.
Tang F. and Ishwaran H. (2017). Random forest missing data algorithms. Statistical Analysis and
Data Mining, 10, 363-377.
See Also
find.interaction,
impute, max.subtree,
plot.competing.risk, plot.rfsrc, plot.survival, plot.variable, predict.rfsrc, print.rfsrc,
quantileReg, rfsrcFast, rfsrcSyn,
subsample,
stat.split, tune, var.select, vimp
breast 5
breast Wisconsin Prognostic Breast Cancer Data
Description
Recurrence of breast cancer from 198 breast cancer patients, all of which exhibited no evidence of
distant metastases at the time of diagnosis. The first 30 features of the data describe characteristics
of the cell nuclei present in the digitized image of a fine needle aspirate (FNA) of the breast mass.
Source
The data were obtained from the UCI machine learning repository, see http://archive.ics.uci.
edu/ml/datasets/Breast+Cancer+Wisconsin+(Prognostic).
Examples
## ------------------------------------------------------------
## Standard analysis
## ------------------------------------------------------------
data(breast, package = "randomForestSRC")
breast <- na.omit(breast)
o <- rfsrc(status ~ ., data = breast, nsplit = 10)
print(o)
## ------------------------------------------------------------
## The data is imbalanced so we use balanced random forests
## with undersampling of the majority class
##
## Specifically let n0, n1 be sample sizes for majority, minority
## cases. We sample 2 x n1 cases with majority, minority cases chosen
## with probabilities n1/n, n0/n where n=n0+n1
## ------------------------------------------------------------
y <- breast$status
o <- rfsrc(status ~ ., data = breast, nsplit = 10,
case.wt = randomForestSRC:::make.wt(y),
sampsize = randomForestSRC:::make.size(y))
print(o)
find.interaction Find Interactions Between Pairs of Variables
Description
Find pairwise interactions between variables.
6 find.interaction
Usage
## S3 method for class 'rfsrc'
find.interaction(object, xvar.names, cause, m.target,
importance = c("permute", "random", "anti",
"permute.ensemble", "random.ensemble", "anti.ensemble"),
method = c("maxsubtree", "vimp"), sorted = TRUE, nvar, nrep = 1, subset,
na.action = c("na.omit", "na.impute"),
seed = NULL, do.trace = FALSE, verbose = TRUE, ...)
Arguments
object An object of class (rfsrc, grow) or (rfsrc, forest).
xvar.names Character vector of names of target x-variables. Default is to use all variables.
cause For competing risk families, integer value between 1 and J indicating the event
of interest, where J is the number of event types. The default is to use the first
event type.
m.target Character value for multivariate families specifying the target outcome to be
used. If left unspecified, the algorithm will choose a default target.
importance Type of variable importance (VIMP). See rfsrc for details.
method Method of analysis: maximal subtree or VIMP. See details below.
sorted Should variables be sorted by VIMP? Does not apply for competing risks.
nvar Number of variables to be used.
nrep Number of Monte Carlo replicates when ‘method="vimp"’.
subset Vector indicating which rows of the x-variable matrix from the object are to be
used. Uses all rows if not specified.
na.action Action to be taken if the data contains NA values. Applies only when ‘method="vimp"’.
seed Seed for random number generator. Must be a negative integer.
do.trace Number of seconds between updates to the user on approximate time to completion.
verbose Set to TRUE for verbose output.
... Further arguments passed to or from other methods.
Details
Using a previously grown forest, identify pairwise interactions for all pairs of variables from a
specified list. There are two distinct approaches specified by the option ‘method’.
1. ‘method="maxsubtree"’
This invokes a maximal subtree analysis. In this case, a matrix is returned where entries [i][i]
are the normalized minimal depth of variable [i] relative to the root node (normalized wrt the
size of the tree) and entries [i][j] indicate the normalized minimal depth of a variable [j] wrt the
maximal subtree for variable [i] (normalized wrt the size of [i]’s maximal subtree). Smaller
[i][i] entries indicate predictive variables. Small [i][j] entries having small [i][i] entries are a
sign of an interaction between variable i and j (note: the user should scan rows, not columns,
for small entries). See Ishwaran et al. (2010, 2011) for more details.
find.interaction 7
2. ‘method="vimp"’
This invokes a joint-VIMP approach. Two variables are paired and their paired VIMP calculated
(refered to as ’Paired’ importance). The VIMP for each separate variable is also calculated.
The sum of these two values is refered to as ’Additive’ importance. A large positive or
negative difference between ’Paired’ and ’Additive’ indicates an association worth pursuing if
the univariate VIMP for each of the paired-variables is reasonably large. See Ishwaran (2007)
for more details.
Computations might be slow depending upon the size of the data and the forest. In such cases,
consider setting ‘nvar’ to a smaller number. If ‘method="maxsubtree"’, consider using a smaller
number of trees in the original grow call.
If ‘nrep’ is greater than 1, the analysis is repeated nrep times and results averaged over the replications
(applies only when ‘method="vimp"’).
Value
Invisibly, the interaction table (a list for competing risk data) or the maximal subtree matrix.
Author(s)
Hemant Ishwaran and Udaya B. Kogalur
References
Ishwaran H. (2007). Variable importance in binary regression trees and forests, Electronic J. Statist.,
1:519-537.
Ishwaran H., Kogalur U.B., Gorodeski E.Z, Minn A.J. and Lauer M.S. (2010). High-dimensional
variable selection for survival data. J. Amer. Statist. Assoc., 105:205-217.
Ishwaran H., Kogalur U.B., Chen X. and Minn A.J. (2011). Random survival forests for highdimensional
data. Statist. Anal. Data Mining, 4:115-132.
See Also
max.subtree, var.select, vimp
Examples
## ------------------------------------------------------------
## find interactions, survival setting
## ------------------------------------------------------------
data(pbc, package = "randomForestSRC")
pbc.obj <- rfsrc(Surv(days,status) ~ ., pbc, importance = TRUE)
find.interaction(pbc.obj, method = "vimp", nvar = 8)
## ------------------------------------------------------------
## find interactions, competing risks
## ------------------------------------------------------------
8 follic
data(wihs, package = "randomForestSRC")
wihs.obj <- rfsrc(Surv(time, status) ~ ., wihs, nsplit = 3, ntree = 100,
importance = TRUE)
find.interaction(wihs.obj)
find.interaction(wihs.obj, method = "vimp")
## ------------------------------------------------------------
## find interactions, regression setting
## ------------------------------------------------------------
airq.obj <- rfsrc(Ozone ~ ., data = airquality, importance = TRUE)
find.interaction(airq.obj, method = "vimp", nrep = 3)
find.interaction(airq.obj)
## ------------------------------------------------------------
## find interactions, classification setting
## ------------------------------------------------------------
iris.obj <- rfsrc(Species ~., data = iris, importance = TRUE)
find.interaction(iris.obj, method = "vimp", nrep = 3)
find.interaction(iris.obj)
## ------------------------------------------------------------
## interactions for multivariate mixed forests
## ------------------------------------------------------------
mtcars2 <- mtcars
mtcars2$cyl <- factor(mtcars2$cyl)
mtcars2$carb <- factor(mtcars2$carb, ordered = TRUE)
mv.obj <- rfsrc(cbind(carb, mpg, cyl) ~., data = mtcars2, importance = TRUE)
find.interaction(mv.obj, method = "vimp", outcome.target = "carb")
find.interaction(mv.obj, method = "vimp", outcome.target = "mpg")
find.interaction(mv.obj, method = "vimp", outcome.target = "cyl")
follic Follicular Cell Lymphoma
Description
Competing risk data set involving follicular cell lymphoma.
Format
A data frame containing:
age age
hgb hemoglobin (g/l)
clinstg clinical stage: 1=stage I, 2=stage II
ch chemotherapy
hd 9
rt radiotherapy
time first failure time
status censoring status: 0=censored, 1=relapse, 2=death
Source
Table 1.4b, Competing Risks: A Practical Perspective.
References
Pintilie M., (2006) Competing Risks: A Practical Perspective. West Sussex: John Wiley and Sons.
Examples
data(follic, package = "randomForestSRC")
follic.obj <- rfsrc(Surv(time, status) ~ ., follic, nsplit = 3, ntree = 100)
hd Hodgkin’s Disease
Description
Competing risk data set involving Hodgkin’s disease.
Format
A data frame containing:
age age
sex gender
trtgiven treatment: RT=radition, CMT=Chemotherapy and radiation
medwidsi mediastinum involvement: N=no, S=small, L=Large
extranod extranodal disease: Y=extranodal disease, N=nodal disease
clinstg clinical stage: 1=stage I, 2=stage II
time first failure time
status censoring status: 0=censored, 1=relapse, 2=death
Source
Table 1.6b, Competing Risks: A Practical Perspective.
References
Pintilie M., (2006) Competing Risks: A Practical Perspective. West Sussex: John Wiley and Sons.
10 impute
Examples
data(hd, package = "randomForestSRC")
housing Ames Iowa Housing Data
Description
Data from the Ames Assessor’s Office used in assessing values of individual residential properties
sold in Ames, Iowa from 2006 to 2010. This is a regression problem and the goal is to predict
"SalePrice" which records the price of a home in thousands of dollars.
References
De Cock, D., (2011). Ames, Iowa: Alternative to the Boston housing data as an end of semester
regression project. Journal of Statistics Education, 19(3), 1–14.
Examples
## load the data
data(housing, package = "randomForestSRC")
## the original data contains lots of missing data
## here's a fast but reasonably accurate way to impute the data
housing2 <- impute(data = housing, mf.q = 10, fast = TRUE)
impute Impute Only Mode
Description
Fast imputation mode. A random forest is grown and used to impute missing data. No ensemble
estimates or error rates are calculated.
Usage
## S3 method for class 'rfsrc'
impute(formula, data,
ntree = 500, nodesize = 1, nsplit = 10,
nimpute = 2, fast = FALSE, blocks,
mf.q, max.iter = 10, eps = 0.01,
ytry = NULL, always.use = NULL, verbose = TRUE,
...)
impute 11
Arguments
formula A symbolic description of the model to be fit. Can be left unspecified if there are
no outcomes or we don’t care to distinguish between y-outcomes and x-variables
in the imputation. Ignored when using multivariate missForest imputation.
data Data frame containing the data to be imputed.
ntree Number of trees to grow.
nodesize Forest average terminal node size.
nsplit Non-negative integer value used to specify random splitting.
nimpute Number of iterations of the missing data algorithm. Ignored for multivariate
missForest; in which case the algorithm iterates until a convergence criteria is
achieved (users can however enforce a maximum number of iterations with the
option max.iter).
fast Use fast random forests, rfsrcFast, in place of rfsrc? Improves speed but is
less accurate.
blocks Integer value specifying the number of blocks the data should be broken up into
(by rows). This can improve computational efficiency when the sample size is
large but imputation efficiency decreases. By default, no action is taken if left
unspecified.
mf.q Use this to turn on missForest (which is off by default). Specifies fraction of
variables (between 0 and 1) used as responses in multivariate missForest imputation.
Can also be an integer, in which case this equals the number of multivariate
responses.
max.iter Maximum number of iterations used when implementing multivariate missForest
imputation.
eps Tolerance value used to determine convergence of multivariate missForest imputation.
ytry Number of variables used as pseudo-responses in unsupervised forests. See
details below.
always.use Character vector of variable names to always be included as a response in multivariate
missForest imputation. Does not apply for other imputation methods.
verbose Send verbose output to terminal (only applies to multivariate missForest imputation).
... Further arguments passed to or from other methods.
Details
1. Grow a forest and use this to impute data. All external calculations such as ensemble calculations,
error rates, etc. are turned off. Use this function if your only interest is imputing the
data.
2. Split statistics are calculated using non-misssing data only. If a node splits on a variable with
missing data, the variable’s missing data is imputed by randomly drawing values from nonmissing
in-bag data. The purpose of this is to make it possible to assign cases to daughter
nodes based on the split.
12 impute
3. If no formula is specified, unsupervised splitting is implemented using a ytry value of sqrt(p)
where p equals the number of variables. More precisely, mtry variables are selected at random,
and for each of these a random subset of ytry variables are selected and defined as the
multivariate pseudo-responses. A multivariate composite splitting rule of dimension ytry is
then applied to each of the mtry multivariate regression problems and the node split on the
variable leading to the best split (Tang and Ishwaran, 2017).
4. If mf.q is specified, a multivariate version of missForest imputation (Stekhoven and Buhlmann,
2012) is applied. A fraction mf.q of variables are used as multivariate responses and split by
the remaining variables using multivariate composite splitting (Tang and Ishwaran, 2017).
Missing data for responses are imputed by prediction. The process is repeated using a new
set of variables for responses (mutually exclusive to the previous fit), until all variables have
been imputed. This is one iteration. The entire process is repeated, and the algorithm iterated
until a convergence criteria is met (specified using options max.iter and eps). Integer values
for mf.q are allowed and interpreted as a request that mf.q variables be selected for the multivariate
response. This is generally the most accurate of all the imputation procedures, but also
the most computationally demanding. However see examples below for strategies to increase
speed.
5. Prior to imputation, the data is processed and records with all values missing are removed, as
are variables having all missing values.
6. If there is no missing data, either before or after processing of the data, the algorithm returns
the processed data and no imputation is performed.
7. The default choice nimpute=2 is chosen for coherence with the default missing data algorithm
implemented in grow mode. Thus, if the user imputes data with nimpute=2 and runs a grow
forest using this imputed data, then performance values such as VIMP and error rates will
coincide with those obtained by running a grow forest on the original non-imputed data using
na.action = "na.impute". Ignored for multivariate missForest.
8. All options are the same as rfsrc and the user should consult the rfsrc help file for details.
Value
Invisibly, the data frame containing the orginal data with imputed data overlayed.
Author(s)
Hemant Ishwaran and Udaya B. Kogalur
References
Ishwaran H., Kogalur U.B., Blackstone E.H. and Lauer M.S. (2008). Random survival forests, Ann.
App. Statist., 2:841-860.
Stekhoven D.J. and Buhlmann P. (2012). MissForest–non-parametric missing value imputation for
mixed-type data. Bioinformatics, 28(1):112-118.
Tang F. and Ishwaran H. (2017). Random forest missing data algorithms. Statistical Analysis and
Data Mining, 10, 363-377.
See Also
rfsrc rfsrcFast
max.subtree 13
Examples
## ------------------------------------------------------------
## example of survival imputation
## ------------------------------------------------------------
## default everything - unsupervised splitting
data(pbc, package = "randomForestSRC")
pbc1.d <- impute(data = pbc)
## imputation using outcome splitting
f <- as.formula(Surv(days, status) ~ .)
pbc2.d <- impute(f, data = pbc, nsplit = 3)
## random splitting can be reasonably good
pbc3.d <- impute(f, data = pbc, splitrule = "random", nimpute = 5)
## ------------------------------------------------------------
## example of regression imputation
## ------------------------------------------------------------
air1.d <- impute(data = airquality, nimpute = 5)
air2.d <- impute(Ozone ~ ., data = airquality, nimpute = 5)
air3.d <- impute(Ozone ~ ., data = airquality, fast = TRUE)
## ------------------------------------------------------------
## multivariate missForest imputation
## ------------------------------------------------------------
data(pbc, package = "randomForestSRC")
## missForest algorithm - uses 1 variable at a time for the response
pbc.d <- impute(data = pbc, mf.q = 1)
## multivariate missForest - use 10 percent of variables as responses
## i.e. multivariate missForest
pbc.d <- impute(data = pbc, mf.q = .01)
## missForest but faster by using random splitting
pbc.d <- impute(data = pbc, mf.q = 1, splitrule = "random")
## missForest but faster by increasing nodesize
pbc.d <- impute(data = pbc, mf.q = 1, nodesize = 20, splitrule = "random")
## missForest but faster by using rfsrcFast
pbc.d <- impute(data = pbc, mf.q = 1, fast = TRUE)
max.subtree Acquire Maximal Subtree Information
14 max.subtree
Description
Extract maximal subtree information from a RF-SRC object. Used for variable selection and identifying
interactions between variables.
Usage
## S3 method for class 'rfsrc'
max.subtree(object,
max.order = 2, sub.order = FALSE, conservative = FALSE, ...)
Arguments
object An object of class (rfsrc, grow) or (rfsrc, forest).
max.order Non-negative integer specifying the target number of order depths. Default is to
return the first and second order depths. Used to identify predictive variables.
Setting ‘max.order=0’ returns the first order depth for each variable by tree. A
side effect is that ‘conservative’ is automatically set to FALSE.
sub.order Set this value to TRUE to return the minimal depth of each variable relative to another
variable. Used to identify interrelationship between variables. See details
below.
conservative If TRUE, the threshold value for selecting variables is calculated using a conservative
marginal approximation to the minimal depth distribution (the method
used in Ishwaran et al. 2010). Otherwise, the minimal depth distribution is
the tree-averaged distribution. The latter method tends to give larger threshold
values and discovers more variables, especially in high-dimensions.
... Further arguments passed to or from other methods.
Details
The maximal subtree for a variable x is the largest subtree whose root node splits on x. Thus,
all parent nodes of x’s maximal subtree have nodes that split on variables other than x. The largest
maximal subtree possible is the root node. In general, however, there can be more than one maximal
subtree for a variable. A maximal subtree may also not exist if there are no splits on the variable.
See Ishwaran et al. (2010, 2011) for details.
The minimal depth of a maximal subtree (the first order depth) measures predictiveness of a variable
x. It equals the shortest distance (the depth) from the root node to the parent node of the maximal
subtree (zero is the smallest value possible). The smaller the minimal depth, the more impact x
has on prediction. The mean of the minimal depth distribution is used as the threshold value for
deciding whether a variable’s minimal depth value is small enough for the variable to be classified
as strong.
The second order depth is the distance from the root node to the second closest maximal subtree of
x. To specify the target order depth, use the max.order option (e.g., setting ‘max.order=2’ returns
the first and second order depths). Setting ‘max.order=0’ returns the first order depth for each
variable for each tree.
Set ‘sub.order=TRUE’ to obtain the minimal depth of a variable relative to another variable. This
returns a pxp matrix, where p is the number of variables, and entries [i][j] are the normalized relative
max.subtree 15
minimal depth of a variable [j] within the maximal subtree for variable [i], where normalization
adjusts for the size of [i]’s maximal subtree. Entry [i][i] is the normalized minimal depth of i
relative to the root node. The matrix should be read by looking across rows (not down columns)
and identifies interrelationship between variables. Small [i][j] entries indicate interactions. See
find.interaction for related details.
For competing risk data, maximal subtree analyses are unconditional (i.e., they are non-event specific).
Value
Invisibly, a list with the following components:
order Order depths for a given variable up to max.order averaged over a tree and
the forest. Matrix of dimension pxmax.order. If ‘max.order=0’, a matrix of
pxntree is returned containing the first order depth for each variable by tree.
count Averaged number of maximal subtrees, normalized by the size of a tree, for each
variable.
nodes.at.depth Number of non-terminal nodes by depth for each tree.
sub.order Average minimal depth of a variable relative to another variable. Can be NULL.
threshold Threshold value (the mean minimal depth) used to select variables.
threshold.1se Mean minimal depth plus one standard error.
topvars Character vector of names of the final selected variables.
topvars.1se Character vector of names of the final selected variables using the 1se threshold
rule.
percentile Minimal depth percentile for each variable.
density Estimated minimal depth density.
second.order.threshold
Threshold for second order depth.
Author(s)
Hemant Ishwaran and Udaya B. Kogalur
References
Ishwaran H., Kogalur U.B., Gorodeski E.Z, Minn A.J. and Lauer M.S. (2010). High-dimensional
variable selection for survival data. J. Amer. Statist. Assoc., 105:205-217.
Ishwaran H., Kogalur U.B., Chen X. and Minn A.J. (2011). Random survival forests for highdimensional
data. Statist. Anal. Data Mining, 4:115-132.
See Also
find.interaction, var.select, vimp
16 nutrigenomic
Examples
## ------------------------------------------------------------
## survival analysis
## first and second order depths for all variables
## ------------------------------------------------------------
data(veteran, package = "randomForestSRC")
v.obj <- rfsrc(Surv(time, status) ~ . , data = veteran)
v.max <- max.subtree(v.obj)
# first and second order depths
print(round(v.max$order, 3))
# the minimal depth is the first order depth
print(round(v.max$order[, 1], 3))
# strong variables have minimal depth less than or equal
# to the following threshold
print(v.max$threshold)
# this corresponds to the set of variables
print(v.max$topvars)
## ------------------------------------------------------------
## regression analysis
## try different levels of conservativeness
## ------------------------------------------------------------
mtcars.obj <- rfsrc(mpg ~ ., data = mtcars)
max.subtree(mtcars.obj)$topvars
max.subtree(mtcars.obj, conservative = TRUE)$topvars
nutrigenomic Nutrigenomic Study
Description
Study the effects of five diet treatments on 21 liver lipids and 120 hepatic gene expression in wildtype
and PPAR-alpha deficient mice. We use a multivariate mixed random forest analysis by regressing
gene expression, diet and genotype (the x-variables) on lipid expressions (the multivariate
y-responses).
References
Martin P.G. et al. (2007). Novel aspects of PPAR-alpha-mediated regulation of lipid and xenobiotic
metabolism revealed through a nutrigenomic study. Hepatology, 45(3), 767–777.
partial 17
Examples
## ------------------------------------------------------------
## multivariate mixed forests
## lipids used as the multivariate y-responses
## ------------------------------------------------------------
## load the data
data(nutrigenomic, package = "randomForestSRC")
## multivariate mixed forest call
mv.obj <- rfsrc(get.mv.formula(colnames(nutrigenomic$lipids)),
data.frame(do.call(cbind, nutrigenomic)),
importance=TRUE, nsplit = 10)
## ------------------------------------------------------------
## plot the standarized performance and VIMP values
## ------------------------------------------------------------
## acquire the error rate for each of the 21-coordinates
## standardize to allow for comparison across coordinates
serr <- get.mv.error(mv.obj, standardize = TRUE)
## acquire standardized VIMP
svimp <- get.mv.vimp(mv.obj, standardize = TRUE)
par(mfrow = c(1,2))
plot(serr, xlab = "Lipids", ylab = "Standardized Performance")
matplot(svimp, xlab = "Genes/Diet/Genotype", ylab = "Standardized VIMP")
partial Acquire Partial Effect of a Variable
Description
Acquire the partial effect of a variable on the ensembles.
Usage
partial.rfsrc(object, oob = TRUE, m.target = NULL,
partial.type = NULL, partial.xvar = NULL, partial.values = NULL,
partial.xvar2 = NULL, partial.values2 = NULL,
partial.time = NULL, seed = NULL, do.trace = FALSE, ...)
18 partial
Arguments
object An object of class (rfsrc, grow).
oob By default out-of-bag values are returned, but inbag values can be requested by
setting this option to FALSE.
m.target Character value for multivariate families specifying the target outcome to be
used. If left unspecified, the algorithm will choose a default target.
partial.type Character value of the type of predicted value. See details below.
partial.xvar Character value specifying the single primary partial x-variable to be used.
partial.values Vector of values that the primary partialy x-variable will assume.
partial.xvar2 Vector of character values specifying the second order x-variables to be used.
partial.values2
Vector of values that the second order x-variables will assume. Each second order
x-variable can only assume a single value. This the length of partial.xvar2
and partial.values2 will be the same. In addition, the user must do the appropriate
conversion for factors, and represent a value as a numeric element.
partial.time For survival families, the time at which the predicted survival value is evaluated
at (depends on partial.type).
seed Negative integer specifying seed for the random number generator.
do.trace Number of seconds between updates to the user on approximate time to completion.
... Further arguments passed to or from other methods.
Details
Out-of-bag (OOB) values are returned by default.
A list of length equal to the number of outcomes (length is one for univariate families) with entries
depending on the underlying family:
1. For regression, the predicted response is returned of dim [n] x [length(partial.values)].
2. For classification, the predicted probabilities are returned of dim [n] x [1 + yvar.nlevels[.]] x [length(partial.values)].
3. For survival, the choices are:
• Relative frequency of mortality (rel.freq) or mortality (mort) is of dim [n] x [length(partial.values)].
• The cumulative hazard function (chf) is of dim [n] x [length(partial.time)] x
[length(partial.values)].
• The survival function (surv) is of dim [n] x [length(partial.time)] x [length(partial.values)].
4. For competing risks, the choices are:
• The expected number of life years lost (years.lost) is of dim [n] x [length(event.info$event.type)] x
[length(partial.values)].
• The cumulative incidence function (cif) is of dim [n] x [length(partial.time)] x
[length(event.info$event.type)] x [length(partial.values)].
• The cumulative hazard function (chf) is of dim [n] x [length(partial.time)] x [length(event.info$event.type)]
x [length(partial.values)].
partial 19
Author(s)
Hemant Ishwaran and Udaya B. Kogalur
References
Ishwaran H., Kogalur U.B. (2007). Random survival forests for R, Rnews, 7(2):25-31.
Ishwaran H., Kogalur U.B., Blackstone E.H. and Lauer M.S. (2008). Random survival forests, Ann.
App. Statist., 2:841-860.
See Also
plot.variable.rfsrc
Examples
## ------------------------------------------------------------
## survival/competing risk
## ------------------------------------------------------------
## survival
data(veteran, package = "randomForestSRC")
v.obj <- rfsrc(Surv(time,status)~., veteran, nsplit = 10, ntree = 100)
partial.obj <- partial(v.obj,
partial.type = "rel.freq",
partial.xvar = "age",
partial.values = v.obj$xvar[, "age"],
partial.time = v.obj$time.interest)
## competing risks
data(follic, package = "randomForestSRC")
follic.obj <- rfsrc(Surv(time, status) ~ ., follic, nsplit = 3, ntree = 100)
partial.obj <- partial(follic.obj,
partial.type = "cif",
partial.xvar = "age",
partial.values = follic.obj$xvar[, "age"],
partial.time = follic.obj$time.interest)
## regression
airq.obj <- rfsrc(Ozone ~ ., data = airquality)
partial.obj <- partial(airq.obj,
partial.xvar = "Wind",
partial.values = airq.obj$xvar[, "Wind"],
oob = FALSE)
## classification
iris.obj <- rfsrc(Species ~., data = iris)
partial.obj <- partial(iris.obj,
partial.xvar = "Sepal.Length",
partial.values = iris.obj$xvar[, "Sepal.Length"])
20 pbc
## multivariate mixed outcomes
mtcars2 <- mtcars
mtcars2$carb <- factor(mtcars2$carb)
mtcars2$cyl <- factor(mtcars2$cyl)
mtcars.mix <- rfsrc(Multivar(carb, mpg, cyl) ~ ., data = mtcars2)
partial.obj <- partial(mtcars.mix,
partial.xvar = "disp",
partial.values = mtcars.mix$xvar[, "disp"])
## second order variable specification
mtcars.obj <- rfsrc(mpg ~., data = mtcars)
partial.obj <- partial(mtcars.obj,
partial.xvar = "cyl",
partial.values = c(4, 8),
partial.xvar2 = c("gear", "disp", "carb"),
partial.values2 = c(4, 200, 3))
pbc Primary Biliary Cirrhosis (PBC) Data
Description
Data from the Mayo Clinic trial in primary biliary cirrhosis (PBC) of the liver conducted between
1974 and 1984. A total of 424 PBC patients, referred to Mayo Clinic during that ten-year interval,
met eligibility criteria for the randomized placebo controlled trial of the drug D-penicillamine. The
first 312 cases in the data set participated in the randomized trial and contain largely complete data.
Source
Flemming and Harrington, 1991, Appendix D.1.
References
Flemming T.R and Harrington D.P., (1991) Counting Processes and Survival Analysis. New York:
Wiley.
Examples
data(pbc, package = "randomForestSRC")
pbc.obj <- rfsrc(Surv(days, status) ~ ., pbc, nsplit = 3)
plot.competing.risk 21
plot.competing.risk Plots for Competing Risks
Description
Plot the ensemble cumulative incidence function (CIF) and cause-specific cumulative hazard function
(CSCHF) from a competing risk analysis.
Usage
## S3 method for class 'rfsrc'
plot.competing.risk(x, plots.one.page = FALSE, ...)
Arguments
x An object of class (rfsrc, grow) or (rfsrc, predict).
plots.one.page Should plots be placed on one page?
... Further arguments passed to or from other methods.
Details
Ensemble ensemble CSCHF and CIF functions for each event type. Does not apply to rightcensored
data. Whenever possible, out-of-bag (OOB) values are displayed.
Author(s)
Hemant Ishwaran and Udaya B. Kogalur
References
Ishwaran H., Gerds T.A., Kogalur U.B., Moore R.D., Gange S.J. and Lau B.M. (2014). Random
survival forests for competing risks. Biostatistics, 15(4):757-773.
See Also
follic, hd, rfsrc, wihs
Examples
## ------------------------------------------------------------
## follicular cell lymphoma
## ------------------------------------------------------------
data(follic, package = "randomForestSRC")
follic.obj <- rfsrc(Surv(time, status) ~ ., follic, nsplit = 3, ntree = 100)
plot.competing.risk(follic.obj)
22 plot.rfsrc
## ------------------------------------------------------------
## competing risk analysis of pbc data from the survival package
## events are transplant (1) and death (2)
## ------------------------------------------------------------
if (library("survival", logical.return = TRUE)) {
data(pbc, package = "survival")
pbc$id <- NULL
plot.competing.risk(rfsrc(Surv(time, status) ~ ., pbc))
}
plot.rfsrc Plot Error Rate and Variable Importance from a RF-SRC analysis
Description
Plot out-of-bag (OOB) error rates and variable importance (VIMP) from a RF-SRC analysis. This
is the default plot method for the package.
Usage
## S3 method for class 'rfsrc'
plot(x, m.target = NULL,
plots.one.page = TRUE, sorted = TRUE, verbose = TRUE, ...)
Arguments
x An object of class (rfsrc, grow), (rfsrc, synthetic), or (rfsrc, predict).
m.target Character value for multivariate families specifying the target outcome to be
used. If left unspecified, the algorithm will choose a default target.
plots.one.page Should plots be placed on one page?
sorted Should variables be sorted by importance values?
verbose Should VIMP be printed?
... Further arguments passed to or from other methods.
Details
Plot cumulative OOB error rates as a function of number of trees and variable importance (VIMP)
if available. Note that the default settings are now such that the error rate is no longer calculated on
every tree and VIMP is only calculated if requested. To get OOB error rates for ever tree, use the
option block.size = 1 when growing or restoring the forest. Likewise, to view VIMP, use the
option importance when growing or restoring the forest.
Author(s)
Hemant Ishwaran and Udaya B. Kogalur
plot.subsample 23
References
Breiman L. (2001). Random forests, Machine Learning, 45:5-32.
Ishwaran H. and Kogalur U.B. (2007). Random survival forests for R, Rnews, 7(2):25-31.
See Also
predict.rfsrc, rfsrc
Examples
## ------------------------------------------------------------
## classification example
## ------------------------------------------------------------
iris.obj <- rfsrc(Species ~ ., data = iris,
block.size = 1, importance = TRUE)
plot(iris.obj)
## ------------------------------------------------------------
## competing risk example
## ------------------------------------------------------------
## use the pbc data from the survival package
## events are transplant (1) and death (2)
if (library("survival", logical.return = TRUE)) {
data(pbc, package = "survival")
pbc$id <- NULL
plot(rfsrc(Surv(time, status) ~ ., pbc, block.size = 1))
}
## ------------------------------------------------------------
## multivariate mixed forests
## ------------------------------------------------------------
mtcars.new <- mtcars
mtcars.new$cyl <- factor(mtcars.new$cyl)
mtcars.new$carb <- factor(mtcars.new$carb, ordered = TRUE)
mv.obj <- rfsrc(cbind(carb, mpg, cyl) ~., data = mtcars.new, block.size = 1)
plot(mv.obj, m.target = "carb")
plot(mv.obj, m.target = "mpg")
plot(mv.obj, m.target = "cyl")
plot.subsample Plot Subsampled VIMP Confidence Intervals
24 plot.subsample
Description
Plots VIMP (variable importance) confidence regions obtained from subsampling a forest.
Usage
## S3 method for class 'rfsrc'
plot.subsample(x, alpha = .05,
standardize = TRUE, normal = TRUE, jknife = TRUE,
target, m.target = NULL, pmax = 75, main = "", cex = 1, ...)
Arguments
x An object obtained from calling subample.
alpha Desired level of significance.
standardize Standardize VIMP? For regression families, VIMP is standardized by dividing
by the variance and then multipled by 100. For all other families, VIMP is scaled
by 100.
normal Use parametric normal confidence regions or nonparametric regions? Generally,
parametric regions perform better.
jknife Use the delete-d jackknife variance estimator?
target For classification families, an integer or character value specifying the class
VIMP will be conditioned on (default is to use unconditional VIMP). For competing
risk families, an integer value between 1 and J indicating the event VIMP
is requested, where J is the number of event types. The default is to use the first
event.
m.target Character value for multivariate families specifying the target outcome to be
used. If left unspecified, the algorithm will choose a default target.
pmax Trims the data to this number of variables (sorted by VIMP).
main Title used for plot.
cex Character expansion used for variable names.
... Further arguments that can be passed to bxp.
Author(s)
Hemant Ishwaran and Udaya B. Kogalur
References
Ishwaran H. and Lu M. (2017). Standard errors and confidence intervals for variable importance in
random forest regression, classification, and survival.
Politis, D.N. and Romano, J.P. (1994). Large sample confidence regions based on subsamples under
minimal assumptions. The Annals of Statistics, 22(4):2031-2050.
Shao, J. and Wu, C.J. (1989). A general theory for jackknife variance estimation. The Annals of
Statistics, 17(3):1176-1197.
plot.survival 25
See Also
subsample
Examples
o <- rfsrc(Ozone ~ ., airquality)
oo <- subsample(o)
plot.subsample(oo)
plot.subsample(oo, jknife = FALSE)
plot.subsample(oo, alpha = .01)
plot(oo)
